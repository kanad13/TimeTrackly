<!DOCTYPE html>
<html lang="en">

<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1.0">
	<title>Multi-Task Time Tracker</title>
	<!-- Load Tailwind CSS -->
	<script src="https://cdn.tailwindcss.com"></script>
	<!-- Load Chart.js for Visualization -->
	<script src="https://cdn.jsdelivr.net/npm/chart.js@4.4.3/dist/chart.umd.min.js"></script>
	<!-- Configure Font -->
	<style>
		@import url('https://fonts.googleapis.com/css2?family=Inter:wght@400;600;700&display=swap');

		body {
			font-family: 'Inter', sans-serif;
		}

		.collapse-icon {
			transition: transform 0.2s;
		}

		.rotate-90 {
			transform: rotate(90deg);
		}

		.paused-card {
			border-left: 4px solid #f97316;
		}

		/* Orange-500 */
		.tab-button.active {
			border-bottom: 3px solid #4f46e5;
			/* Indigo-600 */
			color: #1f2937;
			/* Gray-800 */
			font-weight: 600;
		}
	</style>
</head>

<body class="bg-gray-50 min-h-screen p-4 sm:p-8">

	<div id="app" class="max-w-4xl mx-auto bg-white shadow-2xl rounded-xl p-6 sm:p-10">
		<h1 class="text-3xl font-bold text-gray-800 mb-6 text-center">Multi-Task Tracker</h1>

		<!-- Tab Navigation -->
		<div class="flex border-b border-gray-200 mb-6">
			<button id="tab-tracker" data-tab="tracker"
				class="tab-button active flex-1 py-3 text-center text-gray-500 hover:text-gray-800 transition duration-150">
				Time Tracker
			</button>
			<button id="tab-reports" data-tab="reports"
				class="tab-button flex-1 py-3 text-center text-gray-500 hover:text-gray-800 transition duration-150">
				Reports & Analytics
			</button>
		</div>

		<!-- Content Views -->
		<div id="view-tracker" class="content-view">
			<p class="text-sm text-gray-500 mb-6 text-center">Format: <span
					class="font-mono bg-gray-100 p-1 rounded-md">Project / Task</span></p>

			<!-- Smart Activity Input with Datalist -->
			<div class="flex flex-col sm:flex-row gap-3 mb-4">
				<input list="activity-suggestions" type="text" id="topic-input"
					placeholder="Enter Project / Task or select from suggestions"
					class="flex-grow px-4 py-3 border border-gray-300 rounded-lg text-lg focus:outline-none focus:ring-2 focus:ring-indigo-500 transition duration-150">
				<datalist id="activity-suggestions"></datalist>

				<button id="start-button"
					class="w-full sm:w-32 flex-shrink-0 text-white font-semibold py-3 rounded-lg shadow-md bg-indigo-600 hover:bg-indigo-700 transition duration-300 focus:outline-none focus:ring-4 focus:ring-indigo-300 disabled:bg-gray-400">
					Start
				</button>
			</div>

			<p id="error-message" class="text-sm text-red-500 mb-4 h-5"></p>

			<!-- Active Timers Display -->
			<h2 class="text-xl font-semibold text-gray-700 mb-4 border-b pb-2">Active Timers (<span
					id="active-count">0</span>)</h2>

			<div id="active-timers-list" class="space-y-4 mb-8 min-h-[100px] p-2">
				<p id="no-active-message" class="text-gray-500 text-center py-4">No tasks currently running.</p>
			</div>

			<!-- Data Management Section -->
			<div class="mt-8 pt-4 border-t border-gray-200">
				<h2 class="text-xl font-semibold text-gray-700 mb-4">Data Management</h2>
				<button id="export-button"
					class="w-full bg-gray-600 text-white font-semibold py-3 rounded-lg shadow-md transition duration-300 hover:bg-gray-700 focus:outline-none focus:ring-4 focus:ring-gray-300">
					Export All Data (CSV)
				</button>
			</div>
		</div>

		<div id="view-reports" class="content-view hidden">
			<div id="reports-loading" class="text-center text-gray-500 py-12">Loading historical data...</div>
			<div id="reports-error" class="text-center text-red-500 py-12 hidden">Error loading reports. Check console.</div>

			<div id="reports-content" class="space-y-12 hidden">
				<h3 class="text-2xl font-semibold text-gray-700 border-b pb-2">Time Distribution by Project</h3>
				<div class="flex justify-center h-80">
					<canvas id="project-pie-chart"></canvas>
				</div>

				<h3 class="text-2xl font-semibold text-gray-700 border-b pb-2 pt-6">Daily Time Logged (Last 7 Days)</h3>
				<div class="h-80">
					<canvas id="daily-bar-chart"></canvas>
				</div>
			</div>
		</div>

		<!-- Status and ID Display -->
		<p class="text-sm text-center text-gray-400 mt-6" id="user-id-display">User ID: Loading...</p>
	</div>

	<!-- Local Application Logic -->
	<script>
		// --- Constants ---
		const CONSTANTS = {
			MS_PER_SECOND: 1000,
			MS_PER_HOUR: 3600000,
			MS_PER_DAY: 86400000,
			MAX_INPUT_LENGTH: 100,
			REPORT_DAYS_DEFAULT: 7,
		};

		// --- Global State ---
		let historicalEntries = []; // Holds all completed data from mtt-data.json
		let predefinedSuggestions = []; // Holds suggestions from mtt-suggestions.json
		let activeTimers = {}; // { uuid: { project, task, startTime, accumulatedMs, isPaused } }
		let timerInterval = null;
		let activeChartInstances = []; // To destroy and recreate charts

		// --- DOM Element References ---
		const topicInput = document.getElementById('topic-input');
		const startButton = document.getElementById('start-button');
		const exportButton = document.getElementById('export-button');
		const activeTimersList = document.getElementById('active-timers-list');
		const activeCount = document.getElementById('active-count');
		const noActiveMessage = document.getElementById('no-active-message');
		const userIdDisplay = document.getElementById('user-id-display');
		const errorMessage = document.getElementById('error-message');
		const suggestionsDatalist = document.getElementById('activity-suggestions');
		const reportsLoading = document.getElementById('reports-loading');
		const reportsError = document.getElementById('reports-error');
		const reportsContent = document.getElementById('reports-content');

		// --- Utility: Input Sanitization ---
		/**
		 * Sanitizes user input to prevent issues with special characters
		 * @param {string} str - Input string to sanitize
		 * @returns {string} Sanitized string
		 */
		const sanitizeInput = (str) => {
			if (typeof str !== 'string') return '';
			// Remove potentially dangerous characters and limit length
			return str
				.trim()
				.replace(/[<>\"\']/g, '')
				.substring(0, CONSTANTS.MAX_INPUT_LENGTH);
		};

		// --- Utility: User Notifications ---
		/**
		 * Shows a temporary notification to the user
		 * @param {string} message - Message to display
		 * @param {string} type - Type of notification ('error', 'success', 'info')
		 * @param {number} duration - Duration in milliseconds
		 */
		const showNotification = (message, type = 'info', duration = 4000) => {
			const notification = document.createElement('div');
			const bgColor = type === 'error' ? 'bg-red-100 border-red-400 text-red-700' :
				type === 'success' ? 'bg-green-100 border-green-400 text-green-700' :
					'bg-blue-100 border-blue-400 text-blue-700';

			notification.className = `fixed top-4 right-4 border-l-4 p-4 ${bgColor} rounded shadow-lg z-50 max-w-md transition-opacity duration-300`;
			notification.textContent = message;
			document.body.appendChild(notification);

			setTimeout(() => {
				notification.style.opacity = '0';
				setTimeout(() => notification.remove(), 300);
			}, duration);
		};

		// --- API Communication Layer ---
		/**
		 * Loads historical time entries from server
		 * @throws {Error} If server is unreachable or returns error
		 */
		const loadDataFromServer = async () => {
			try {
				const response = await fetch("/api/data");
				if (!response.ok) throw new Error(`Server responded with ${response.status}`);
				const data = await response.json();
				historicalEntries = data.map((entry) => ({
					...entry,
					endTime: new Date(entry.endTime), // Convert ISO string back to Date object
				}));
			} catch (error) {
				console.error("FATAL: Could not load data from server.", error);
				showNotification("Failed to load data from server. Please check if the server is running.", "error", 0);
				document.getElementById("app").innerHTML = `<div class='text-red-600 text-center p-8'><h1>Connection Error</h1><p>Could not connect to the local server. Is it running? Please start the server and refresh the page.</p></div>`;
				throw error;
			}
		};

		/**
		 * Saves historical time entries to server
		 * @throws {Error} If save operation fails
		 */
		const saveDataToServer = async () => {
			try {
				const response = await fetch("/api/data", {
					method: "POST",
					headers: { "Content-Type": "application/json" },
					body: JSON.stringify(historicalEntries, null, 2),
				});
				if (!response.ok) {
					throw new Error(`Server responded with ${response.status}`);
				}
			} catch (error) {
				console.error("Error saving historical data:", error);
				showNotification("Failed to save data. Your changes may be lost!", "error");
				throw error;
			}
		};

		/**
		 * Loads active timer state from server (for session restoration)
		 */
		const loadActiveStateFromServer = async () => {
			try {
				const response = await fetch("/api/active-state");
				if (!response.ok) throw new Error(`Server responded with ${response.status}`);
				const savedTimers = await response.json();
				activeTimers = {}; // Clear existing state before loading
				if (savedTimers && Object.keys(savedTimers).length > 0) {
					for (const id in savedTimers) {
						const timer = savedTimers[id];
						timer.startTime = timer.startTime ? new Date(timer.startTime) : null;
						activeTimers[id] = timer;
					}
				}
			} catch (error) {
				console.error("Could not load active state from server. Starting fresh.", error);
				showNotification("Could not restore previous session. Starting fresh.", "info");
				activeTimers = {}; // On failure, ensure state is clean
			}
		};

		/**
		 * Saves current active timer state to server
		 * Updates UI counter and visibility after save
		 * @throws {Error} If save operation fails
		 */
		const saveActiveStateToServer = async () => {
			const serializableTimers = {};
			for (const id in activeTimers) {
				const timer = activeTimers[id];
				serializableTimers[id] = {
					...timer,
					startTime: timer.startTime ? timer.startTime.toISOString() : null,
				};
			}
			try {
				const response = await fetch("/api/active-state", {
					method: "POST",
					headers: { "Content-Type": "application/json" },
					body: JSON.stringify(serializableTimers, null, 2),
				});
				if (!response.ok) {
					throw new Error(`Server responded with ${response.status}`);
				}
			} catch (error) {
				console.error("Error saving active state:", error);
				showNotification("Failed to save timer state. Changes may be lost on refresh!", "error");
				throw error;
			}
			// This part is UI-related and can run even if the save fails
			activeCount.textContent = Object.keys(activeTimers).length;
			noActiveMessage.classList.toggle('hidden', Object.keys(activeTimers).length > 0);
		};

		/**
		 * Loads task/project suggestions from server
		 */
		const loadSuggestionsFromServer = async () => {
			try {
				const response = await fetch("/api/suggestions");
				if (!response.ok) throw new Error(`Server responded with ${response.status}`);
				predefinedSuggestions = await response.json();
			} catch (error) {
				console.error("Could not load suggestions from server.", error);
				// App can continue with an empty list of predefined suggestions
				predefinedSuggestions = [];
			}
		};

		// --- Utility Functions ---
		/**
		 * Generates a unique identifier using the Web Crypto API
		 * @returns {string} UUID v4 string
		 */
		const generateUUID = () => crypto.randomUUID();

		/**
		 * Formats a duration in seconds to HH:MM:SS format
		 * @param {number} seconds - Duration in seconds
		 * @returns {string} Formatted duration string (HH:MM:SS)
		 */
		const formatDuration = (seconds) => {
			const h = Math.floor(seconds / 3600);
			const m = Math.floor((seconds % 3600) / 60);
			const s = seconds % 60;
			return [h, m, s].map(v => v < 10 ? "0" + v : v).join(':');
		};

		/**
		 * Creates a unique key for identifying running tasks
		 * @param {string} project - Project name
		 * @param {string} task - Task name
		 * @returns {string} Lowercase key in format "project:task"
		 */
		const getRunningTasksKey = (project, task) => `${project.toLowerCase()}:${task.toLowerCase()}`;

		/**
		 * Calculates total elapsed milliseconds for a timer including paused time
		 * @param {Object} timer - Timer object
		 * @param {number} timer.accumulatedMs - Milliseconds accumulated while paused
		 * @param {boolean} timer.isPaused - Whether timer is currently paused
		 * @param {Date|null} timer.startTime - When timer was last started
		 * @returns {number} Total elapsed milliseconds
		 */
		const calculateElapsedMs = (timer) => {
			let elapsed = timer.accumulatedMs || 0;
			if (!timer.isPaused && timer.startTime) {
				elapsed += (Date.now() - timer.startTime.getTime());
			}
			return elapsed;
		};

		/**
		 * Generates an array of distinct colors for chart visualization
		 * @param {number} count - Number of colors needed
		 * @returns {string[]} Array of hex color codes
		 */
		const getDistinctColors = (count) => {
			const colors = ['#4f46e5', '#f97316', '#10b981', '#ef4444', '#3b82f6', '#f59e0b', '#8b5cf6', '#ec4899', '#06b6d4', '#84cc16'];
			const result = [];
			for (let i = 0; i < count; i++) result.push(colors[i % colors.length]);
			return result;
		};

		// --- Datalist and Suggestions ---
		/**
		 * Populates the datalist with predefined and recent activity suggestions
		 */
		const populateSuggestions = () => {
			suggestionsDatalist.innerHTML = '';
			const recentActivities = new Set(
				historicalEntries.map(entry =>
					(entry.project && entry.task) ? `${entry.project.trim()} / ${entry.task.trim()}` : null
				).filter(Boolean)
			);
			const combined = new Set([...predefinedSuggestions, ...recentActivities]);
			combined.forEach(activity => {
				const option = document.createElement('option');
				option.value = activity;
				suggestionsDatalist.appendChild(option);
			});
		};

		// --- Core UI Management ---
		/**
		 * Renders all active timers grouped by project with collapsible sections
		 */
		const renderActiveTimers = () => {
			activeTimersList.innerHTML = '';
			const timersArray = Object.entries(activeTimers).map(([id, data]) => ({ id, ...data }));

			if (timersArray.length === 0) {
				noActiveMessage.classList.remove('hidden');
				activeCount.textContent = 0;
				return;
			}
			noActiveMessage.classList.add('hidden');
			activeCount.textContent = timersArray.length;

			const projects = timersArray.reduce((acc, timer) => {
				const projectKey = timer.project;
				if (!acc[projectKey]) { acc[projectKey] = []; }
				acc[projectKey].push(timer);
				return acc;
			}, {});

			const sortedProjects = Object.keys(projects).sort((a, b) => a.toLowerCase().localeCompare(b.toLowerCase()));

			sortedProjects.forEach(projectKey => {
				const tasks = projects[projectKey];
				const projectId = projectKey.replace(/\s/g, '_');

				const projectHeader = document.createElement('div');
				projectHeader.className = 'flex justify-between items-center p-3 bg-gray-200 hover:bg-gray-300 cursor-pointer rounded-lg shadow-sm font-semibold text-gray-800';
				projectHeader.setAttribute('data-target', projectId);
				projectHeader.innerHTML = `
					<div class="flex items-center space-x-2">
						<svg id="icon-${projectId}" class="collapse-icon w-4 h-4 text-indigo-600" fill="none" stroke="currentColor" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M9 5l7 7-7 7"></path></svg>
						<span>${projectKey} (${tasks.length})</span>
					</div>
				`;

				const taskList = document.createElement('div');
				taskList.id = projectId;
				taskList.className = 'transition-all duration-300 ease-in-out overflow-hidden h-0 space-y-2 pt-2';

				projectHeader.addEventListener('click', () => {
					const isCollapsed = taskList.classList.contains('h-0');
					const icon = document.getElementById(`icon-${projectId}`);
					if (isCollapsed) {
						taskList.classList.remove('h-0');
						taskList.style.height = `${taskList.scrollHeight}px`;
						icon.classList.add('rotate-90');
					} else {
						taskList.style.height = '0';
						icon.classList.remove('rotate-90');
						taskList.addEventListener('transitionend', () => taskList.classList.add('h-0'), { once: true });
					}
				});

				tasks.forEach(activity => {
					const card = document.createElement('div');
					card.id = `timer-card-${activity.id}`;
					let cardClasses = 'flex flex-col sm:flex-row justify-between items-start sm:items-center bg-white p-3 rounded-lg shadow-sm border border-gray-100 ml-4';
					if (activity.isPaused) { cardClasses += ' paused-card'; }
					card.className = cardClasses;

					const statusText = activity.isPaused ? '<span class="text-orange-500 font-bold mr-2">(Paused)</span>' : '';
					card.innerHTML = `
						<div class="flex flex-col text-left mb-2 sm:mb-0">
							<span class="text-sm font-medium text-gray-700">${statusText} ${activity.task}</span>
							<span class="text-xs text-gray-400">${activity.isPaused ? 'Accumulated' : 'Running Since'} ${activity.startTime ? activity.startTime.toLocaleTimeString() : 'N/A'}</span>
						</div>
						<div class="flex items-center space-x-2.5 mt-2 sm:mt-0">
							<span id="duration-${activity.id}" class="text-lg font-mono text-gray-800 w-24 text-right flex-shrink-0">${formatDuration(Math.floor(calculateElapsedMs(activity) / 1000))}</span>
							<button data-action="toggle" class="${activity.isPaused ? 'bg-green-500 hover:bg-green-600' : 'bg-yellow-500 hover:bg-yellow-600'} text-white text-xs px-3 py-1 rounded-lg transition duration-150 shadow-sm flex-shrink-0">${activity.isPaused ? 'Resume' : 'Pause'}</button>
							<button data-action="stop" class="bg-red-500 text-white text-xs px-3 py-1 rounded-lg hover:bg-red-600 transition duration-150 shadow-sm flex-shrink-0">Stop</button>
							<button data-action="delete" class="bg-gray-400 text-white text-xs px-3 py-1 rounded-lg hover:bg-gray-500 transition duration-150 shadow-sm flex-shrink-0">Delete</button>
						</div>
					`;

					card.querySelector('[data-action="toggle"]').addEventListener('click', () => toggleTimer(activity.id));
					card.querySelector('[data-action="stop"]').addEventListener('click', () => stopTimer(activity.id));
					card.querySelector('[data-action="delete"]').addEventListener('click', () => deleteTimer(activity.id));

					taskList.appendChild(card);
				});
				activeTimersList.appendChild(projectHeader);
				activeTimersList.appendChild(taskList);
			});
		};

		const updateTimerDisplay = () => {
			let hasRunningTimers = Object.values(activeTimers).some(t => !t.isPaused);
			for (const id in activeTimers) {
				const activity = activeTimers[id];
				const durationSpan = document.getElementById(`duration-${id}`);
				if (durationSpan) {
					const elapsedSeconds = Math.floor(calculateElapsedMs(activity) / 1000);
					durationSpan.textContent = formatDuration(elapsedSeconds);
				}
			}
			if (!hasRunningTimers && timerInterval) {
				clearInterval(timerInterval);
				timerInterval = null;
			}
		};

		const startTimerDisplay = () => {
			if (!timerInterval) {
				timerInterval = setInterval(updateTimerDisplay, 1000);
			}
		};

		// --- Core State Management Functions ---
		/**
		 * Starts a new timer for a project/task
		 * Validates input, checks for duplicates, and saves state
		 */
		const startNewTimer = async () => {
			errorMessage.textContent = '';
			const fullTopic = sanitizeInput(topicInput.value);
			if (!fullTopic) {
				errorMessage.textContent = "Please enter or select a Project / Task.";
				return;
			}

			const parts = fullTopic.split('/').map(p => sanitizeInput(p));
			const project = parts[0] || 'Uncategorized';
			const task = parts[1] || 'Task';
			const taskKey = getRunningTasksKey(project, task);

			if (Object.values(activeTimers).some(t => getRunningTasksKey(t.project, t.task) === taskKey)) {
				errorMessage.textContent = `Error: The task "${project} / ${task}" is already running.`;
				return;
			}

			const newId = generateUUID();
			activeTimers[newId] = { project, task, startTime: new Date(), accumulatedMs: 0, isPaused: false };

			topicInput.value = '';
			
			try {
				await saveActiveStateToServer();
				renderActiveTimers();
				startTimerDisplay();
			} catch (error) {
				// If save failed, remove the timer we just added
				delete activeTimers[newId];
				errorMessage.textContent = "Failed to start timer. Please try again.";
			}
		};

		/**
		 * Toggles a timer between paused and running states
		 * @param {string} id - UUID of the timer to toggle
		 */
		const toggleTimer = async (id) => {
			const timer = activeTimers[id];
			if (!timer) return;

			if (timer.isPaused) { // Resuming
				timer.isPaused = false;
				timer.startTime = new Date();
			} else { // Pausing
				timer.accumulatedMs += (Date.now() - timer.startTime.getTime());
				timer.startTime = null;
				timer.isPaused = true;
			}

			await saveActiveStateToServer();
			renderActiveTimers();
			startTimerDisplay();
		};

		/**
		 * Deletes a timer without saving it to history
		 * @param {string} id - UUID of the timer to delete
		 */
		const deleteTimer = async (id) => {
			if (!activeTimers[id]) return;
			delete activeTimers[id];
			await saveActiveStateToServer();
			renderActiveTimers();
		};

		/**
		 * Stops a timer and saves it to historical data
		 * Discards timers with zero duration
		 * @param {string} id - UUID of the timer to stop
		 */
		const stopTimer = async (id) => {
			const activity = activeTimers[id];
			if (!activity) return;

			const finalDurationMs = calculateElapsedMs(activity);
			if (finalDurationMs <= 0) {
				deleteTimer(id); // Just delete it, don't save a zero-duration entry
				errorMessage.textContent = 'Task of zero duration was discarded.';
				setTimeout(() => errorMessage.textContent = '', 3000);
				return;
			}

			const endTime = new Date();
			delete activeTimers[id]; // Remove from active state first

			const newEntry = {
				project: activity.project,
				task: activity.task,
				totalDurationMs: finalDurationMs,
				durationSeconds: Math.round(finalDurationMs / 1000),
				endTime: endTime.toISOString(),
				createdAt: new Date().toISOString()
			};

			historicalEntries.push(newEntry);

			// Asynchronously save both states. Active state is more critical to save first.
			await saveActiveStateToServer();
			await saveDataToServer();

			renderActiveTimers(); // Update UI immediately

			const tempStatus = document.createElement('p');
			tempStatus.className = 'text-center text-sm text-green-600 mt-2';
			tempStatus.textContent = `Saved ${activity.project} / ${activity.task} (${formatDuration(newEntry.durationSeconds)})`;
			activeTimersList.insertAdjacentElement('afterend', tempStatus);
			setTimeout(() => tempStatus.remove(), 4000);

			populateSuggestions(); // Refresh suggestions
		};

		/**
		 * Exports all historical data as a CSV file
		 * Includes computed duration in minutes
		 */
		const exportData = () => {
			if (historicalEntries.length === 0) {
				alert('No data to export.');
				return;
			}
			exportButton.textContent = 'Generating...';
			exportButton.disabled = true;

			const headers = ["project", "task", "endTime", "durationSeconds", "durationMinutes", "totalDurationMs"];
			const csvRows = [headers.join(',')];
			historicalEntries.forEach(entry => {
				const row = {
					...entry,
					endTime: (new Date(entry.endTime)).toISOString(),
					durationMinutes: (entry.durationSeconds / 60).toFixed(2)
				};
				const values = headers.map(header => `"${(row[header] || '').toString().replace(/"/g, '""')}"`);
				csvRows.push(values.join(','));
			});

			const blob = new Blob([csvRows.join('\n')], { type: 'text/csv;charset=utf-8;' });
			const link = document.createElement('a');
			link.href = URL.createObjectURL(blob);
			link.download = `time_tracker_export_${new Date().toISOString().split('T')[0]}.csv`;
			link.click();

			exportButton.textContent = 'Export All Data (CSV)';
			exportButton.disabled = false;
		};

		// --- Tab Switching Logic ---
		const switchTab = (targetTab) => {
			document.querySelectorAll('.content-view').forEach(view => view.classList.add('hidden'));
			document.querySelectorAll('.tab-button').forEach(btn => btn.classList.remove('active'));
			document.getElementById(`view-${targetTab}`).classList.remove('hidden');
			document.getElementById(`tab-${targetTab}`).classList.add('active');
			if (targetTab === 'reports') renderReportsView();
		};

		document.getElementById('tab-tracker').addEventListener('click', () => switchTab('tracker'));
		document.getElementById('tab-reports').addEventListener('click', () => switchTab('reports'));

		// --- REPORT GENERATION ---
		const renderReportsView = () => {
			reportsLoading.classList.remove('hidden');
			reportsContent.classList.add('hidden');
			reportsError.classList.add('hidden');

			activeChartInstances.forEach(chart => chart.destroy());
			activeChartInstances = [];

			if (historicalEntries.length === 0) {
				reportsLoading.textContent = "No data recorded yet. Track a task to see reports!";
				return;
			}

			const projectDurations = historicalEntries.reduce((acc, entry) => {
				acc[entry.project] = (acc[entry.project] || 0) + entry.totalDurationMs;
				return acc;
			}, {});
			const projectLabels = Object.keys(projectDurations);
			const projectData = Object.values(projectDurations);
			const projectColors = getDistinctColors(projectLabels.length);

			const dailyDurations = {};
			for (let i = 6; i >= 0; i--) {
				const day = new Date(Date.now() - i * 86400000);
				dailyDurations[day.toISOString().split('T')[0]] = 0;
			}
			historicalEntries.forEach(entry => {
				const dateKey = (new Date(entry.endTime)).toISOString().split('T')[0];
				if (dailyDurations.hasOwnProperty(dateKey)) {
					dailyDurations[dateKey] += entry.totalDurationMs;
				}
			});

			reportsLoading.classList.add('hidden');
			reportsContent.classList.remove('hidden');

			const pieCtx = document.getElementById('project-pie-chart').getContext('2d');
			activeChartInstances.push(new Chart(pieCtx, {
				type: 'doughnut', data: { labels: projectLabels, datasets: [{ data: projectData, backgroundColor: projectColors }] },
				options: { responsive: true, maintainAspectRatio: false, plugins: { legend: { position: 'right' }, tooltip: { callbacks: { label: c => `${c.label}: ${formatDuration(Math.round(c.parsed / 1000))}` } } } }
			}));

			const barCtx = document.getElementById('daily-bar-chart').getContext('2d');
			activeChartInstances.push(new Chart(barCtx, {
				type: 'bar', data: { labels: Object.keys(dailyDurations).map(d => new Date(d).toLocaleDateString('en-US', { weekday: 'short' })), datasets: [{ label: 'Hours Logged', data: Object.values(dailyDurations).map(ms => ms / 3600000), backgroundColor: '#4f46e5' }] },
				options: { responsive: true, maintainAspectRatio: false, scales: { y: { beginAtZero: true, title: { display: true, text: 'Hours' } } }, plugins: { legend: { display: false } } }
			}));
		};

		// --- Initialization ---
		const initializeApp = async () => {
			try {
				userIdDisplay.textContent = "Status: Local Mode";
				startButton.addEventListener('click', startNewTimer);
				exportButton.addEventListener('click', exportData);

				await loadSuggestionsFromServer();  // 1. Load predefined suggestions
				await loadDataFromServer();       // 2. Load historical data
				await loadActiveStateFromServer();  // 3. Load active timers from server

				renderActiveTimers();               // 4. Render the UI with loaded state
				populateSuggestions();              // 5. Populate suggestions list

				if (Object.values(activeTimers).some(t => !t.isPaused)) {
					startTimerDisplay();            // 6. Start the timer display loop if needed
				}

				showNotification("Application loaded successfully!", "success", 2000);
			} catch (error) {
				console.error("Fatal error during initialization:", error);
				showNotification("Failed to initialize application. Please refresh the page.", "error", 0);
			}
		};

		// --- Cleanup on visibility change (pause timer updates when tab is hidden) ---
		document.addEventListener('visibilitychange', () => {
			if (document.hidden && timerInterval) {
				clearInterval(timerInterval);
				timerInterval = null;
			} else if (!document.hidden && Object.values(activeTimers).some(t => !t.isPaused)) {
				startTimerDisplay();
			}
		});

		// --- Cleanup on page unload ---
		window.addEventListener('beforeunload', (e) => {
			if (timerInterval) {
				clearInterval(timerInterval);
				timerInterval = null;
			}
			// Optionally warn user if there are active timers
			const activeTimerCount = Object.keys(activeTimers).length;
			if (activeTimerCount > 0) {
				e.preventDefault();
				e.returnValue = `You have ${activeTimerCount} active timer(s). Your progress is saved, but make sure the server is running when you return.`;
			}
		});

		// --- Global error handler ---
		window.addEventListener('error', (event) => {
			console.error('Global error caught:', event.error);
			showNotification("An unexpected error occurred. Check the console for details.", "error");
		});

		window.addEventListener('unhandledrejection', (event) => {
			console.error('Unhandled promise rejection:', event.reason);
			showNotification("An unexpected error occurred. Check the console for details.", "error");
		});

		initializeApp();
	</script>
</body>

</html>
