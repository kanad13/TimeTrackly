<!DOCTYPE html>
<html lang="en">

<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1.0">
	<title>Multi-Task Time Tracker (React)</title>
	<link rel="icon"
		href="data:image/svg+xml,<svg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 100 100'><text y='75' font-size='75' fill='%234f46e5'>‚è±</text></svg>">
	<!-- Load Tailwind CSS -->
	<script src="https://cdn.tailwindcss.com"></script>
	<!-- Load Chart.js for Visualization -->
	<script src="https://cdn.jsdelivr.net/npm/chart.js@4.4.3/dist/chart.umd.min.js"></script>
	<!-- Load React and ReactDOM -->
	<script src="https://unpkg.com/react@18/umd/react.development.js"></script>
	<script src="https://unpkg.com/react-dom@18/umd/react-dom.development.js"></script>
	<!-- Load Babel to transpile JSX in the browser -->
	<script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
	<!-- Load Firebase (Compat library for browser compatibility) -->
	<script src="https://www.gstatic.com/firebasejs/11.6.1/firebase-app-compat.js"></script>
	<script src="https://www.gstatic.com/firebasejs/11.6.1/firebase-auth-compat.js"></script>
	<script src="https://www.gstatic.com/firebasejs/11.6.1/firebase-firestore-compat.js"></script>

	<!-- Configure Font and Styles -->
	<style>
		@import url('https://fonts.googleapis.com/css2?family=Inter:wght@400;600;700&display=swap');

		body {
			font-family: 'Inter', sans-serif;
		}

		.collapse-icon {
			transition: transform 0.2s;
		}

		.rotate-90 {
			transform: rotate(90deg);
		}

		.paused-card {
			border-left: 4px solid #f97316;
			/* Orange-500 */
		}

		.tab-button.active {
			border-bottom: 3px solid #4f46e5;
			/* Indigo-600 */
			color: #1f2937;
			/* Gray-800 */
			font-weight: 600;
		}
	</style>
</head>

<body class="bg-gray-50 min-h-screen p-4 sm:p-8">

	<!-- React Root Container -->
	<div id="root"></div>

	<!-- React Application Script -->
	<script type="text/babel">
		// Firebase Imports (Compat library - more stable for browser-based single-file apps)
		const firebase = window.firebase;

		const { useState, useEffect, useMemo, useRef } = React;

		// --- Utility Functions ---
		const generateUUID = () => crypto.randomUUID();
		const formatDuration = (seconds) => {
			const h = Math.floor(seconds / 3600);
			const m = Math.floor((seconds % 3600) / 60);
			const s = seconds % 60;
			return [h, m, s].map(v => v < 10 ? "0" + v : v).join(':');
		};
		const getRunningTasksKey = (project, task) => `${project.toLowerCase()}:${task.toLowerCase()}`;
		const calculateElapsedMs = (timer) => {
			let elapsed = timer.accumulatedMs || 0;
			if (!timer.isPaused && timer.startTime) {
				elapsed += (Date.now() - new Date(timer.startTime).getTime());
			}
			return elapsed;
		};
		const getDistinctColors = (count) => {
			const colors = ['#4f46e5', '#f97316', '#10b981', '#ef4444', '#3b82f6', '#f59e0b', '#8b5cf6', '#ec4899', '#06b6d4', '#84cc16'];
			const result = [];
			for (let i = 0; i < count; i++) { result.push(colors[i % colors.length]); }
			return result;
		};
		const HARDCODED_SUGGESTIONS = ["Project Gemini / Coding", "Project Gemini / Documentation", "Internal Admin / Meetings", "Internal Admin / Email Response", "Client X / Proposal Draft", "Learning / Tutorial Videos"];


		// --- React Components ---

		const TimerCard = ({ timer, onToggle, onStop, onDelete }) => {
			const [displayTime, setDisplayTime] = useState(formatDuration(Math.floor(calculateElapsedMs(timer) / 1000)));

			useEffect(() => {
				if (timer.isPaused) {
					setDisplayTime(formatDuration(Math.floor(calculateElapsedMs(timer) / 1000)));
					return;
				}

				const intervalId = setInterval(() => {
					setDisplayTime(formatDuration(Math.floor(calculateElapsedMs(timer) / 1000)));
				}, 1000);

				return () => clearInterval(intervalId);
			}, [timer]);


			const cardClasses = `flex flex-col sm:flex-row justify-between items-start sm:items-center bg-white p-3 rounded-lg shadow-sm border border-gray-100 ml-4 ${timer.isPaused ? 'paused-card' : ''} ${timer.isSaving ? 'opacity-60' : ''}`;

			return (
				<div className={cardClasses}>
					<div className="flex flex-col text-left mb-2 sm:mb-0">
						<span className="text-sm font-medium text-gray-700">
							{timer.isPaused && <span className="text-orange-500 font-bold mr-2">(Paused)</span>}
							{timer.task}
						</span>
						<span className="text-xs text-gray-400">
							{timer.isPaused ? 'Accumulated' : 'Running Since'} {timer.startTime ? new Date(timer.startTime).toLocaleTimeString() : 'N/A'}
						</span>
					</div>

					<div className="flex items-center space-x-2.5 mt-2 sm:mt-0">
						<span className="text-lg font-mono text-gray-800 w-24 text-right flex-shrink-0">
							{timer.isSaving ? 'Saving...' : displayTime}
						</span>
						<button onClick={() => onToggle(timer.id)} disabled={timer.isSaving} className={timer.isPaused ? 'bg-green-500 text-white text-xs px-3 py-1 rounded-lg hover:bg-green-600 transition duration-150 shadow-sm flex-shrink-0' : 'bg-yellow-500 text-white text-xs px-3 py-1 rounded-lg hover:bg-yellow-600 transition duration-150 shadow-sm flex-shrink-0'}>{timer.isPaused ? 'Resume' : 'Pause'}</button>
						<button onClick={() => onStop(timer.id)} disabled={timer.isSaving} className="bg-red-500 text-white text-xs px-3 py-1 rounded-lg hover:bg-red-600 transition duration-150 shadow-sm flex-shrink-0">Stop</button>
						<button onClick={() => onDelete(timer.id)} disabled={timer.isSaving} className="bg-gray-400 text-white text-xs px-3 py-1 rounded-lg hover:bg-gray-500 transition duration-150 shadow-sm flex-shrink-0">Delete</button>
					</div>
				</div>
			);
		};

		const ProjectGroup = ({ project, tasks, onToggle, onStop, onDelete }) => {
			const [isCollapsed, setIsCollapsed] = useState(false);
			const projectId = project.replace(/\s/g, '_');
			const contentRef = useRef(null);

			const toggleCollapse = () => setIsCollapsed(!isCollapsed);

			return (
				<div>
					<div onClick={toggleCollapse} className="flex justify-between items-center p-3 bg-gray-200 hover:bg-gray-300 cursor-pointer rounded-lg shadow-sm font-semibold text-gray-800">
						<div className="flex items-center space-x-2">
							<svg className={`collapse-icon w-4 h-4 text-indigo-600 ${!isCollapsed ? 'rotate-90' : ''}`} fill="none" stroke="currentColor" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path strokeLinecap="round" strokeLinejoin="round" strokeWidth="2" d="M9 5l7 7-7 7"></path></svg>
							<span>{`${project} (${tasks.length})`}</span>
						</div>
					</div>
					<div ref={contentRef} style={{ maxHeight: !isCollapsed ? `${contentRef.current?.scrollHeight}px` : '0px' }} className="transition-all duration-300 ease-in-out overflow-hidden">
						<div className="space-y-2 pt-2">
							{tasks.map(timer => (
								<TimerCard key={timer.id} timer={timer} onToggle={onToggle} onStop={onStop} onDelete={onDelete} />
							))}
						</div>
					</div>
				</div>
			)
		};

		const ReportsView = ({ db, userId, appId }) => {
			const [loading, setLoading] = useState(true);
			const [error, setError] = useState(null);
			const [entries, setEntries] = useState([]);
			const chartInstances = useRef([]); // To destroy charts on unmount

			const getEntriesCollection = () => {
				if (!db || !userId) throw new Error("Database not ready.");
				return db.collection(`artifacts/${appId}/users/${userId}/entries`);
			};

			// Fetch data on component mount
			useEffect(() => {
				const fetchData = async () => {
					if (!userId) return;
					try {
						const snapshot = await getEntriesCollection().get();
						const allEntries = snapshot.docs.map(doc => {
							const data = doc.data();
							// Convert Firestore Timestamp to Date for endTime
							if (data.endTime && typeof data.endTime.toDate === 'function') {
								data.endTime = data.endTime.toDate();
							}
							return data;
						});
						setEntries(allEntries);
					} catch (e) {
						console.error("Error fetching report data:", e);
						setError("Failed to load historical data.");
					} finally {
						setLoading(false);
					}
				};
				fetchData();
			}, [userId, db, appId]);

			// Render charts when data is available
			useEffect(() => {
				if (entries.length > 0) {
					// Cleanup previous charts
					chartInstances.current.forEach(chart => chart.destroy());
					chartInstances.current = [];

					// 1. Project Pie Chart Data
					const projectDurations = entries.reduce((acc, entry) => {
						const project = entry.project || 'Unknown';
						acc[project] = (acc[project] || 0) + entry.totalDurationMs;
						return acc;
					}, {});
					const projectLabels = Object.keys(projectDurations);
					const pieChart = new Chart(document.getElementById('project-pie-chart'), {
						type: 'doughnut',
						data: {
							labels: projectLabels,
							datasets: [{ data: projectLabels.map(label => projectDurations[label]), backgroundColor: getDistinctColors(projectLabels.length), hoverOffset: 4 }]
						},
						options: { responsive: true, maintainAspectRatio: false, plugins: { legend: { position: 'right' }, tooltip: { callbacks: { label: (c) => `${c.label}: ${formatDuration(Math.round(c.parsed / 1000))}` } } } }
					});
					chartInstances.current.push(pieChart);


					// 2. Daily Bar Chart Data
					const dailyDurations = {};
					const lastSevenDaysLabels = [];
					for (let i = 6; i >= 0; i--) {
						const day = new Date(Date.now() - i * 86400000);
						const dateKey = day.toISOString().split('T')[0];
						lastSevenDaysLabels.push(day.toLocaleDateString('en-US', { weekday: 'short', day: 'numeric' }));
						dailyDurations[dateKey] = 0;
					}
					entries.forEach(entry => {
						if (entry.endTime) {
							let endDate = entry.endTime;
							// Handle both Date objects and Firestore Timestamps
							if (typeof endDate === 'object' && endDate.toDate && typeof endDate.toDate === 'function') {
								endDate = endDate.toDate();
							}
							const dateKey = new Date(endDate).toISOString().split('T')[0];
							if (dailyDurations.hasOwnProperty(dateKey)) { dailyDurations[dateKey] += entry.totalDurationMs; }
						}
					});
					const dailyDataHours = Object.values(dailyDurations).slice(-7).map(ms => ms / 3600000);

					const barChart = new Chart(document.getElementById('daily-bar-chart'), {
						type: 'bar',
						data: {
							labels: lastSevenDaysLabels,
							datasets: [{ label: 'Hours Logged', data: dailyDataHours, backgroundColor: '#4f46e5', borderRadius: 4 }]
						},
						options: { responsive: true, maintainAspectRatio: false, scales: { y: { beginAtZero: true, title: { display: true, text: 'Hours' } } }, plugins: { legend: { display: false }, tooltip: { callbacks: { label: (c) => `Total: ${c.parsed.y.toFixed(2)} hours` } } } }
					});
					chartInstances.current.push(barChart);
				}

				return () => { // Cleanup on unmount
					chartInstances.current.forEach(chart => chart.destroy());
				};
			}, [entries]);

			if (loading) return <div className="text-center text-gray-500 py-12">Loading historical data...</div>;
			if (error) return <div className="text-center text-red-500 py-12">{error}</div>;
			if (entries.length === 0) return <div className="text-center text-gray-500 py-12">No data recorded yet. Start tracking to see reports!</div>

			return (
				<div className="space-y-12">
					<h3 className="text-2xl font-semibold text-gray-700 border-b pb-2">Time Distribution by Project</h3>
					<div className="flex justify-center h-80"><canvas id="project-pie-chart"></canvas></div>
					<h3 className="text-2xl font-semibold text-gray-700 border-b pb-2 pt-6">Daily Time Logged (Last 7 Days)</h3>
					<div className="h-80"><canvas id="daily-bar-chart"></canvas></div>
				</div>
			);
		};


		const App = () => {
			const [db, setDb] = useState(null);
			const [auth, setAuth] = useState(null);
			const [userId, setUserId] = useState(null);
			const [appId, setAppId] = useState('default-app-id');
			const [activeTimers, setActiveTimers] = useState({});
			const [currentView, setCurrentView] = useState('tracker'); // 'tracker' or 'reports'
			const [inputValue, setInputValue] = useState('');
			const [errorMessage, setErrorMessage] = useState('');
			const [statusMessage, setStatusMessage] = useState('');
			const [suggestions, setSuggestions] = useState(HARDCODED_SUGGESTIONS);

			const getEntriesCollection = () => {
				if (!db || !userId) throw new Error("Database not ready.");
				return db.collection(`artifacts/${appId}/users/${userId}/entries`);
			};

			// --- Effects for Initialization and Data Sync ---

			// 1. Initialize Firebase
			useEffect(() => {
				const envAppId = typeof __app_id !== 'undefined' ? __app_id : 'default-app-id';
				const firebaseConfig = JSON.parse(typeof __firebase_config !== 'undefined' ? __firebase_config : '{}');
				const initialAuthToken = typeof __initial_auth_token !== 'undefined' ? __initial_auth_token : null;

				setAppId(envAppId);

				try {
					const app = firebase.initializeApp(firebaseConfig);
					const firestoreDb = firebase.firestore();
					const firebaseAuth = firebase.auth();
					setDb(firestoreDb);
					setAuth(firebaseAuth);

					const authAction = initialAuthToken ? firebaseAuth.signInWithCustomToken(initialAuthToken) : firebaseAuth.signInAnonymously();

					authAction.catch(err => console.error("Authentication failed:", err));

					firebaseAuth.onAuthStateChanged((user) => {
						if (user) {
							setUserId(user.uid);
						} else {
							setUserId(null);
						}
					});
				} catch (error) {
					console.error("Error initializing Firebase:", error);
				}
			}, []);

			// 2. Load timers from localStorage on mount
			useEffect(() => {
				try {
					const savedTimers = localStorage.getItem('activeTimers');
					if (savedTimers) {
						setActiveTimers(JSON.parse(savedTimers));
					}
				} catch (e) {
					console.error("Could not load timers from localStorage", e)
				}
			}, []);

			// 3. Save timers to localStorage whenever they change
			useEffect(() => {
				try {
					localStorage.setItem('activeTimers', JSON.stringify(activeTimers));
				} catch (e) {
					console.error("Could not save timers to localStorage", e);
				}
			}, [activeTimers]);

			// 4. Fetch recent activities for suggestions when user is logged in
			useEffect(() => {
				const fetchRecentActivities = async () => {
					if (!db || !userId) return;
					try {
						const snapshot = await getEntriesCollection().get();
						const activities = new Set();
						snapshot.forEach((doc) => {
							const data = doc.data();
							if (data.project && data.task) {
								activities.add(`${data.project.trim()} / ${data.task.trim()}`);
							}
						});
						setSuggestions(prev => Array.from(new Set([...HARDCODED_SUGGESTIONS, ...Array.from(activities)])));
					} catch (error) {
						console.error("Error fetching recent activities:", error);
					}
				};

				fetchRecentActivities();
			}, [userId, db]);


			// --- Core Timer Logic ---

			const startNewTimer = () => {
				setErrorMessage('');
				const fullTopic = inputValue.trim();
				if (!fullTopic) {
					setErrorMessage("Please enter or select a Project / Task.");
					return;
				}

				const parts = fullTopic.split('/').map(p => p.trim());
				const project = parts[0] || 'Uncategorized Project';
				const task = parts[1] || 'Uncategorized Task';
				const taskKey = getRunningTasksKey(project, task);

				if (Object.values(activeTimers).some(t => getRunningTasksKey(t.project, t.task) === taskKey)) {
					setErrorMessage(`Error: The task "${project} / ${task}" is already running.`);
					return;
				}

				const newId = generateUUID();
				setActiveTimers(prev => ({
					...prev,
					[newId]: { id: newId, project, task, startTime: new Date().toISOString(), accumulatedMs: 0, isPaused: false }
				}));
				setInputValue('');
			};

			const toggleTimer = (id) => {
				const timer = activeTimers[id];
				if (!timer) return;

				const updatedTimer = { ...timer };
				if (timer.isPaused) {
					updatedTimer.isPaused = false;
					updatedTimer.startTime = new Date().toISOString();
				} else {
					updatedTimer.accumulatedMs += (Date.now() - new Date(timer.startTime).getTime());
					updatedTimer.startTime = null;
					updatedTimer.isPaused = true;
				}
				setActiveTimers(prev => ({ ...prev, [id]: updatedTimer }));
			};

			const deleteTimer = (id) => {
				setActiveTimers(prev => {
					const nextState = { ...prev };
					delete nextState[id];
					return nextState;
				});
			};

			const stopTimer = async (id) => {
				const activity = { ...activeTimers[id] };
				if (!activity) return;

				setActiveTimers(prev => ({ ...prev, [id]: { ...prev[id], isSaving: true } }));

				const finalDurationMs = calculateElapsedMs(activity);
				const durationSeconds = Math.round(finalDurationMs / 1000);

				if (durationSeconds <= 0) {
					deleteTimer(id);
					setErrorMessage('Task stopped instantly and deleted (zero duration).');
					setTimeout(() => setErrorMessage(''), 3000);
					return;
				}

				const newEntry = {
					project: activity.project,
					task: activity.task,
					totalDurationMs: finalDurationMs,
					durationSeconds: durationSeconds,
					endTime: firebase.firestore.Timestamp.fromDate(new Date()),
					userId: userId,
					createdAt: firebase.firestore.Timestamp.now()
				};

				try {
					await getEntriesCollection().add(newEntry);
					deleteTimer(id); // Remove from UI on successful save
					setStatusMessage(`Saved: ${activity.project} / ${activity.task} (${formatDuration(durationSeconds)})`);
					setTimeout(() => setStatusMessage(''), 4000);
				} catch (e) {
					console.error("Error adding document: ", e);
					setErrorMessage(`ERROR saving. Please try again.`);
					setActiveTimers(prev => ({ ...prev, [id]: { ...prev[id], isSaving: false } })); // Re-enable card on failure
				}
			};

			// --- Data Export ---
			const exportData = async () => {
				if (!userId) { return; }
				try {
					const snapshot = await getEntriesCollection().get();
					let data = snapshot.docs.map(doc => ({ id: doc.id, ...doc.data() }));

					if (data.length === 0) return;

					const headers = ["id", "project", "task", "endTime", "durationSeconds", "totalDurationMs"];
					const csvRows = [headers.join(',')];
					for (const row of data) {
						const values = headers.map(h => {
							let val = row[h];
							// Handle Firestore Timestamp
							if (h === 'endTime' && val && typeof val.toDate === 'function') {
								val = val.toDate().toISOString();
							} else if (h === 'endTime') {
								val = new Date(val).toISOString();
							}
							const escaped = ('' + (val || '')).replace(/"/g, '""');
							return `"${escaped}"`;
						});
						csvRows.push(values.join(','));
					}

					const blob = new Blob([csvRows.join('\n')], { type: 'text/csv;charset=utf-8;' });
					const link = document.createElement('a');
					link.href = URL.createObjectURL(blob);
					link.download = `time_tracker_export_${new Date().toISOString().split('T')[0]}.csv`;
					link.click();
				} catch (error) {
					console.error("Error exporting data:", error);
				}
			};


			// --- Derived State for Rendering ---
			const timersArray = Object.values(activeTimers);
			const projects = useMemo(() => {
				return timersArray.reduce((acc, timer) => {
					if (!acc[timer.project]) acc[timer.project] = [];
					acc[timer.project].push(timer);
					return acc;
				}, {});
			}, [activeTimers]);
			const sortedProjects = Object.keys(projects).sort((a, b) => a.toLowerCase().localeCompare(b.toLowerCase()));

			// --- Render ---
			return (
				<div className="max-w-4xl mx-auto bg-white shadow-2xl rounded-xl p-6 sm:p-10">
					<h1 className="text-3xl font-bold text-gray-800 mb-6 text-center">Multi-Task Tracker</h1>

					<div className="flex border-b border-gray-200 mb-6">
						<button onClick={() => setCurrentView('tracker')} className={`tab-button flex-1 py-3 text-center text-gray-500 hover:text-gray-800 transition duration-150 ${currentView === 'tracker' && 'active'}`}>
							Time Tracker
						</button>
						<button onClick={() => setCurrentView('reports')} className={`tab-button flex-1 py-3 text-center text-gray-500 hover:text-gray-800 transition duration-150 ${currentView === 'reports' && 'active'}`}>
							Reports & Analytics
						</button>
					</div>

					{currentView === 'tracker' && (
						<div>
							<p className="text-sm text-gray-500 mb-6 text-center">Format: <span className="font-mono bg-gray-100 p-1 rounded-md">Project / Task</span></p>
							<div className="flex flex-col sm:flex-row gap-3 mb-4">
								<input list="activity-suggestions" type="text" value={inputValue} onChange={(e) => setInputValue(e.target.value)} placeholder="Enter Project / Task or select from suggestions" className="flex-grow px-4 py-3 border border-gray-300 rounded-lg text-lg focus:outline-none focus:ring-2 focus:ring-indigo-500 transition duration-150" />
								<datalist id="activity-suggestions">
									{suggestions.map(s => <option key={s} value={s} />)}
								</datalist>
								<button onClick={startNewTimer} disabled={!userId} className="w-full sm:w-32 flex-shrink-0 text-white font-semibold py-3 rounded-lg shadow-md bg-indigo-600 hover:bg-indigo-700 transition duration-300 focus:outline-none focus:ring-4 focus:ring-indigo-300 disabled:bg-gray-400">
									Start
								</button>
							</div>

							<p className="text-sm text-red-500 mb-4 h-5">{errorMessage}</p>
							{statusMessage && <p className="text-sm text-green-600 text-center mb-4">{statusMessage}</p>}


							<h2 className="text-xl font-semibold text-gray-700 mb-4 border-b pb-2">Active Timers ({timersArray.length})</h2>
							<div className="space-y-4 mb-8 min-h-[100px] p-2">
								{timersArray.length === 0 ? (
									<p className="text-gray-500 text-center py-4">No tasks currently running.</p>
								) : (
									sortedProjects.map(project => (
										<ProjectGroup
											key={project}
											project={project}
											tasks={projects[project]}
											onToggle={toggleTimer}
											onStop={stopTimer}
											onDelete={deleteTimer}
										/>
									))
								)}
							</div>

							<div className="mt-8 pt-4 border-t border-gray-200">
								<h2 className="text-xl font-semibold text-gray-700 mb-4">Data Management</h2>
								<button onClick={exportData} disabled={!userId} className="w-full bg-gray-600 text-white font-semibold py-3 rounded-lg shadow-md transition duration-300 hover:bg-gray-700 focus:outline-none focus:ring-4 focus:ring-gray-300">
									Export All Data (CSV)
								</button>
							</div>
						</div>
					)}

					{currentView === 'reports' && <ReportsView db={db} userId={userId} appId={appId} />}

					<p className="text-sm text-center text-gray-400 mt-6">User ID: {userId || 'Loading...'}</p>
				</div>
			);
		};

		const container = document.getElementById('root');
		const root = ReactDOM.createRoot(container);
		root.render(<App />);

	</script>
</body>

</html>
